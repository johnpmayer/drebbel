use std::str::FromStr;
use ast::*;

grammar;

// Utilities

Comma<T>: Vec<T> = { // (0)
    <v:(<T> ",")*> <e:T?> => match e { // (1)
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// Literals and Identifiers

Num: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();

Literal: Literal = <n:Num> => Literal::Number(n);

Identifier: String = <s:r"[a-z][a-zA-Z0-9_]*"> => String::from(s);

VariableName: VariableName = Identifier => VariableName(<>);

SubroutineName: SubroutineName = Identifier => SubroutineName(<>);

// Expressions with precedence rules (higher precedence earlier in the program)

UnaryOp1: UnaryOperator = {
    "-" => UnaryOperator::Minus,
    "!" => UnaryOperator::Not,
};

CallSubroutine: Box<Expression>=  {
    <sub:SubroutineName> "(" <parameters:Comma<Expression>> ")" =>
        Box::new(Expression::CallSubByValue(sub, parameters))
};

Expression1: Box<Expression> = {
    VariableName => Box::new(Expression::Var(<>)),
    Literal => Box::new(Expression::Lit(<>)),
    UnaryOp1 Expression1 => Box::new(Expression::ApplyUnOp(<>)),
    CallSubroutine,
    "(" <Expression> ")",
};

BinaryOp2: InfixBinaryOperator = {
    "*" => InfixBinaryOperator::Mul,
    "/" => InfixBinaryOperator::Div,
    "%" => InfixBinaryOperator::Mod,
    "&&" => InfixBinaryOperator::And,
};

Expression2: Box<Expression> = {
    Expression2 BinaryOp2 Expression1 => Box::new(Expression::ApplyInfixBinOp(<>)), // Left-assoc
    Expression1,
};

BinaryOp3: InfixBinaryOperator = {
    "+" => InfixBinaryOperator::Add,
    "-" => InfixBinaryOperator::Sub,
    "||" => InfixBinaryOperator::Or,
};

Expression3: Box<Expression> = {
    Expression3 BinaryOp3 Expression2 => Box::new(Expression::ApplyInfixBinOp(<>)), // Left-assoc
    Expression2,
};

BinaryOp4: InfixBinaryOperator = {
    "==" => InfixBinaryOperator::Eq,
};

Expression4: Box<Expression> = {
    Expression4 BinaryOp4 Expression3 => Box::new(Expression::ApplyInfixBinOp(<>)), // Left-assoc
    Expression3,
};

Expression5: Box<Expression> = {
    "IF" <expr_test:Expression> "THEN" <expr_true:Expression> "ELSE" <expr_false:Expression4> =>
        Box::new(Expression::Conditional(expr_test, expr_true, expr_false)),
    Expression4,
};

// Left-associative; Expression is on left, Factor is on right
pub Expression: Box<Expression> = Expression5;

pub Statement: Statement = {
    CallSubroutine => Statement::EvaluateIgnore(<>),
    <v:VariableName> ":=" <expr:Expression> => Statement::Assignment(v, expr),
    "RETURN" <expr:Expression?> => Statement::Return(expr),
    => Statement::Empty,
};

StatementList: StatementList = {
    Statement => StatementList::Single(<>),
    <s:Statement> ";" <sl:StatementList> => StatementList::Sequence(s, Box::new(sl)),
};

CompoundStatement: CompoundStatement = {
    "BEGIN" <sl:StatementList> "END" => CompoundStatement(sl),
};

Subroutine: (SubroutineName, Subroutine) = {
    "SUB" <sn:SubroutineName> "(" <parameters:Comma<VariableName>> ")" <block:CompoundStatement> "." => (sn, Subroutine {
        parameters: parameters,
        implementation: Implementation::Block(block)
    })
};

pub Program: Program = {
    <subs:Subroutine*> <cs:CompoundStatement> "." => Program {
        subroutines: subs.iter().cloned().collect(), // convert to a Vec<(k,v)> to HashMap<k,v>
        entry: cs
    }
};