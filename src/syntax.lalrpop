use std::str::FromStr;
use ast::*;

grammar;

Num: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();

Comma<T>: Vec<T> = { // (0)
    <v:(<T> ",")*> <e:T?> => match e { // (1)
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Literal: Literal = {
    <n:Num> => Literal::Number(n),
};

Identifier: String = {
    <s:r"[a-z][a-zA-Z0-9_]*"> => String::from(s)
};

VariableName: VariableName = {
    Identifier => VariableName(<>)
};

SubroutineName: SubroutineName = {
    Identifier => SubroutineName(<>)
};

// Skipping the unary plus operator... it feels pointless
UnaryOp: UnaryOperator = {
    "-" => UnaryOperator::Minus
};

Factor: Box<Expression> = {
    VariableName => Box::new(Expression::Var(<>)),
    Literal => Box::new(Expression::Lit(<>)),
    UnaryOp Factor => Box::new(Expression::ApplyUnOp(<>)),
    "(" <Expression> ")",
};

FactorOp: InfixBinaryOperator = {
    "*" => InfixBinaryOperator::Mul,
    "/" => InfixBinaryOperator::Div,
    "%" => InfixBinaryOperator::Mod,
};

// Left-associative; Factor is on left, Term is on right
Term: Box<Expression> = {
    Term FactorOp Factor => Box::new(Expression::ApplyInfixBinOp(<>)),
    Factor,
};

TermOp: InfixBinaryOperator = {
    "+" => InfixBinaryOperator::Add,
    "-" => InfixBinaryOperator::Sub,
};

CallSubroutine: Box<Expression>=  {
    <sub:SubroutineName> "(" <parameters:Comma<Expression>> ")" =>
        Box::new(Expression::CallSubByValue(sub, parameters))
};

// Left-associative; Expression is on left, Factor is on right
pub Expression: Box<Expression> = {
    Expression TermOp Term => Box::new(Expression::ApplyInfixBinOp(<>)),
    Term,
    CallSubroutine,
};

pub Statement: Statement = {
    CallSubroutine => Statement::EvaluateIgnore(<>),
    <v:VariableName> ":=" <expr:Expression> => Statement::Assignment(v, expr),
    "RETURN" <expr:Expression?> => Statement::Return(expr),
    => Statement::Empty,
};

StatementList: StatementList = {
    Statement => StatementList::Single(<>),
    <s:Statement> ";" <sl:StatementList> => StatementList::Sequence(s, Box::new(sl)),
};

CompoundStatement: CompoundStatement = {
    "BEGIN" <sl:StatementList> "END" => CompoundStatement(sl),
};

Subroutine: (SubroutineName, Subroutine) = {
    "SUB" <sn:SubroutineName> "(" <parameters:Comma<VariableName>> ")" <block:CompoundStatement> "." => (sn, Subroutine {
        parameters: parameters,
        block: block
    })
};

pub Program: Program = {
    <subs:Subroutine*> <cs:CompoundStatement> "." => Program {
        subroutines: subs.iter().cloned().collect(), // convert to a Vec<(k,v)> to HashMap<k,v>
        entry: cs
    }
};