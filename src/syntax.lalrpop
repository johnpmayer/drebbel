use std::str::FromStr;
use ast::{Literal, InfixBinaryOperator, Expression, UnaryOperator};

grammar;

//WS: () = <s:r"[ \n\t]+"> => ();

Num: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();

Literal: Literal = {
    <n:Num> => Literal::Number(n),
};

// Skipping the unary plus operator... it feels pointless/academic
UnaryOp: UnaryOperator = {
    "-" => UnaryOperator::Minus
};

Factor: Box<Expression> = {
    Literal => Box::new(Expression::Lit(<>)), // (4)
    UnaryOp Factor => Box::new(Expression::ApplyUnOp(<>)),
    "(" <Expression> ")",
};

FactorOp: InfixBinaryOperator = {
    "*" => InfixBinaryOperator::Mul,
    "/" => InfixBinaryOperator::Div,
    "%" => InfixBinaryOperator::Mod,
};

// Left-associative; Factor is on left, Term is on right
Term: Box<Expression> = {
    Term FactorOp Factor => Box::new(Expression::ApplyInfixBinOp(<>)),
    Factor,
};

TermOp: InfixBinaryOperator = { // (3)
    "+" => InfixBinaryOperator::Add,
    "-" => InfixBinaryOperator::Sub,
};

// Left-associative; Expression is on left, Factor is on right
pub Expression: Box<Expression> = { // (1)
    Expression TermOp Term => Box::new(Expression::ApplyInfixBinOp(<>)), // (2)
    Term,
};