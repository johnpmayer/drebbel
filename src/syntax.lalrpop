use std::str::FromStr;
use ast::*;

grammar;

Num: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();

Literal: Literal = {
    <n:Num> => Literal::Number(n),
};

Variable: Variable = {
    <s:r"[a-z][a-zA-Z0-9]*"> => Variable(String::from(s))
};

// Skipping the unary plus operator... it feels pointless/academic
UnaryOp: UnaryOperator = {
    "-" => UnaryOperator::Minus
};

Factor: Box<Expression> = {
    Variable => Box::new(Expression::Var(<>)),
    Literal => Box::new(Expression::Lit(<>)),
    UnaryOp Factor => Box::new(Expression::ApplyUnOp(<>)),
    "(" <Expression> ")",
};

FactorOp: InfixBinaryOperator = {
    "*" => InfixBinaryOperator::Mul,
    "/" => InfixBinaryOperator::Div,
    "%" => InfixBinaryOperator::Mod,
};

// Left-associative; Factor is on left, Term is on right
Term: Box<Expression> = {
    Term FactorOp Factor => Box::new(Expression::ApplyInfixBinOp(<>)),
    Factor,
};

TermOp: InfixBinaryOperator = {
    "+" => InfixBinaryOperator::Add,
    "-" => InfixBinaryOperator::Sub,
};

// Left-associative; Expression is on left, Factor is on right
pub Expression: Box<Expression> = {
    Expression TermOp Term => Box::new(Expression::ApplyInfixBinOp(<>)),
    Term,
};

Statement: Statement = {
    <v:Variable> ":=" <expr:Expression> => Statement::Assignment(v, expr),
    // Compound
    => Statement::Empty,
};

StatementList: StatementList = {
    Statement => StatementList::Single(<>),
    <s:Statement> ";" <sl:StatementList> => StatementList::Sequence(s, Box::new(sl)),
};